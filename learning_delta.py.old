import numpy as np
import csv 
import math
import sys
import json
import scipy
from scipy.linalg import fractional_matrix_power

'''This script in Python 3 is a working example of learning algorithms for two
things so far:
    
    1. Using the Delta Rule to learn feature values for a set of morphemes.
    2. Using rigid rotations that apply to a related set of morphemes in order
    to find correct feature values for that set from a base configuration of
    another set that is in a different inflectional class. For example, to learn
    FV's for the affixes of German weak nouns from a base configuration of
    affixes for nouns that take -er in the plural.'''

'''In order to import the right json files, we give the script the following
command-line arguments:
    
    For Delta Rule learning, one argument: the name of the language and morpheme type: e.g.
    <german-geben-stems> 
    
    For Learning by rotations, two arguments: the name of the language being
    learned followed by the name of the source: e.g. <german-kaufen-stems>
    followed by <german-geben-stems>. If we are learning the stem allomorphms for
    weak verb kaufen from, the base configuration of strong verb geben. Thus
    assumes that we have the necessary json files already presetn in the
    directory, generated by the script readparadigmdata.py'''

'''Import the following as json files:
    
    Phi
    y (correct morphemes for each position)
    feature values for starting position
    morpheme list
    
    
Return the following:
    
    Competition matrix after learning
    Morpheme vectors after learning
    number of iterations
    '''

def import_data(typ, lang, label):
    f = open(typ+'.'+lang+label+'.json', 'r')
    d = json.load(f)
    f.close()
    return d

def dump_array_as_list(lang, label, a):
    array_as_list = a.tolist()
    f = open('array'+lang+'.'+label+'.json', 'w')
    json.dump(array_as_list, f)
    f.close()

def printMatrix(M, title, colHeadings, asterisks=False):
    sizeM = np.shape(M)
    if len(colHeadings) > sizeM[1]:
        print("Too many column headings for matrix {0:30s}\n\n".format(title))
        return
    print("{0:30s}\n\n".format(title))
    for j in range(len(colHeadings)):
        print("{0:>8}".format(colHeadings[j]), end=' ')
    print('\n')
    for i in range(sizeM[0]):
        for j in range(sizeM[1]):
            if np.argmax(M[i]) == j and asterisks:
               ast = '*'
            else:
               ast =''
            print("{0:>8.3f}{1:>1s}".format(M[i,j], ast), end=' ')
        print('')
    print('\n\n')
    return

def normalize(M):
    sizeM = np.shape(M)
    for j in range(sizeM[1]):
        denom = np.sqrt(np.dot(M[:,j], M[:,j]))
        if denom != 0:
            M[:,j] = M[:,j]/denom
    return M

def getRotationMatrix(morpheme, target):
    sizeMorpheme = np.shape(morpheme)
    t = target
    u = morpheme #Assume it is already normalized.
    pr = (t - np.dot(u,t)*u)
    v = pr/np.sqrt(np.dot(pr,pr))
    uu = np.outer(u, u)
    vv = np.outer(v, v)
    P = uu + vv
    Q = np.identity(sizeMorpheme[0]) - P
    normmorpheme = np.sqrt(np.dot(morpheme, morpheme))
    normtarget = np.sqrt(np.dot(target, target))
    cost = np.dot(morpheme, target)/(normmorpheme*normtarget)
    sint = np.sqrt(1-cost**2)
    uv = np.column_stack((u,v))
    cssc = np.vstack((np.array([cost, -sint]), np.array([sint, cost])))
    R = Q + np.matmul(np.matmul(uv, cssc), uv.transpose())
    return R




class DeltaorRotate:
    
    def __init__(self, lang, source=None):

        self.Phi = np.array(import_data('array', lang, '.Phi'))
        self.sizePhi = np.shape(self.Phi)
        self.TPM = np.array(import_data('array', lang, '.TPM'))
        self.sizeTPM = np.shape(self.TPM)
        if source == 'random':
            self.B = np.random.rand(self.sizePhi[1], self.sizeTPM[1])
        else:
            if source:
                self.B = np.array(import_data('array', source, '.B'))
            else:
                self.B = np.array(import_data('array', lang, '.B'))
        self.FVS = import_data('FVlist', lang, '')
        self.mlist = import_data('morphemelist', lang, '')
        self.y = import_data('y', lang, '')
        self.activ = np.matmul(self.Phi, self.B)
        self.sizeA = np.shape(self.activ)
        self.sizeB = np.shape(self.B)
        self.solved = False

    def learndelta(self):
        eta = 0.1
        for it in range(1000):
            allCorrect = True
            for i in range(self.sizePhi[0]):
                index_of_best = np.argmax(self.activ[i])
                if index_of_best != self.y[i]:
                    allCorrect = False
                    for j in range(self.sizeB[1]):
                        self.B[:,j] += eta*(1.414*self.TPM[i,j]-np.matmul(self.Phi[i,:],self.B[:,j]))*self.Phi[i,:].transpose()
            self.B = normalize(self.B)
            self.activ = np.matmul(self.Phi, self.B)
            if allCorrect:
                print("Solved by Delta rule in", it,  "iterations\n")
                self.solved = True
                return
        return

    def learnrotate(self):
        Rtotal = np.identity(self.sizeB[0])
        for it in range(30):
            self.activ = np.matmul(self.Phi, self.B)
            print('Activations at the beginning of iteration', it, '\n\n', self.activ)
            allCorrect = True
            for i in range(self.sizePhi[0]):
                index_of_best = np.argmax(self.activ[i])
                if index_of_best != self.y[i]:
                    allCorrect = False
                    R = getRotationMatrix(self.B[:,self.y[i]], self.Phi[i,:].transpose())
                    Rtotal = np.matmul(np.real(fractional_matrix_power(R,1/20)), Rtotal)
                    self.B = np.real(np.matmul(fractional_matrix_power(R,1/20),self.B))
            print('Feature values after rotating in iteration', it, '\n\n', self.B)
            self.activ = np.matmul(self.Phi, self.B)
            if allCorrect:
                print("Solved by rotations in", it,  "iterations\n")
                self.solved = True
                printMatrix(Rtotal, 'Aggregate rotation matrix', [])
                return
        return


    def getB(self):
        return self.B

    def getActiv(self):
        return self.activ

    def getmlist(self):
        return self.mlist


if len(sys.argv) > 1:
    lang = sys.argv[1]
    if len(sys.argv) > 2:
        source = sys.argv[2]
    else:
        source = None
else:
    print('You need at least one command line argument:')
    print('First argument identifies the language and morpheme type.')
    print('If there is a second argument, if it is the word <random>, the bundle of feature values B is set to random values rather than from the json file. If it is anything else, it is the name of a source bundle of feature values from which to rotate.')
    sys.exit()

    
if source == None or source == 'random':
    data = DeltaorRotate(lang, source)
    printMatrix(data.getActiv(), 'Competition matrix before learning', data.getmlist(), True)
    printMatrix(data.getB(), 'Feature values before learning', data.getmlist())
    data.learndelta()
    printMatrix(data.getActiv(), 'Competition matrix after learning', data.getmlist(), True)
    printMatrix(data.getB(), 'Feature values after learning', data.getmlist())
else:
    data = DeltaorRotate(lang, source)
    printMatrix(data.getActiv(), 'Competition matrix before learning', data.getmlist(), True)
    printMatrix(data.getB(), 'Feature values before learning', data.getmlist())
    data.learnrotate()
    printMatrix(data.getActiv(), 'Competition matrix after learning', data.getmlist(), True)
    printMatrix(data.getB(), 'Feature values after learning', data.getmlist())

'''If we want to learn feature values for morphemes of some lexeme by rotation,
we start with the set of learned feature values for some lexeme of a different
class and use only rotations to find correct values for the new class. For
example, for stems of German verbs, strong verbs with three different stem
exponents such as geben (geb, gib, gab) works as a base class since the maximum
number of possible exponents occurs. We then rotate the vectors for the three
stem allomorphs of geben to find values that give us exponent #1 (kauf corresponding to geb) for kaufen.'''


if data.solved:
    dump_array_as_list('.'+lang, 'B', data.B)




